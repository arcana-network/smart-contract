// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "./interfaces/IForwarder.sol";
import "./interfaces/IFactoryForwarder.sol";
import "./interfaces/IArcanaForwarder.sol";

/*
 * @title Forwarder
 * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.
 Forwards calls from gateway to beacon proxy which will be delegated to Arcana logic contract
 */
contract Forwarder is IForwarder, EIP712Upgradeable, UUPSUpgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using ECDSA for bytes32;
    /// @dev Factory Interface contract
    IFactoryForwarder public factory;

    bytes32 private constant _FORWARDTYPEHASH =
        keccak256("ForwardRequest(address from,address to,uint256 nonce,string method)");

    /// @dev methods to function type hash for forwarder call
    mapping(string => string) public methodMappings;

    // newAddress => oldAddress
    mapping(address => address) public mfaMapping;
    // user => app => MFA-enabled/Not
    mapping(address => mapping(address => bool)) public mfaEnabledApps;

    event ForwardTransaction(address indexed from, address indexed to, uint256 indexed nonce, string method);

    event UpgradeAuth();

    /// @dev only valid arcana contract i.e, Arcana/DID/Factory/Forwarder
    modifier onlyVallidArcanaContract(address to) {
        require(
            IFactoryForwarder(factory).app(to) != address(0) ||
                address(IFactoryForwarder(factory)) == to ||
                IFactoryForwarder(factory).did() == to ||
                address(this) == to,
            "Invalid contract for meta transaction"
        );
        _;
    }

    function setMethodMappings(string[] memory method, string[] memory funcSigns) external onlyOwner {
        require(method.length == funcSigns.length, "param_length_mismatch");

        for (uint256 i = 0; i < method.length; i++) {
            methodMappings[method[i]] = funcSigns[i];
        }
    }

    mapping(address => uint256) private _nonces;
    /// @dev Only gateway node will have access
    modifier onlyGatewayNode() {
        require(factory.gateway(msg.sender).x != bytes32(0), "only_gateway");
        _;
    }

    function generateMainTypeHash(string memory method) internal view returns (bytes32) {
        string memory _methodHash = methodMappings[method];

        require(keccak256(bytes(_methodHash)) != keccak256(""), "Arcana function not found");
        bytes memory _fhash;
        if (bytes(method)[0] > "F") {
            _fhash = bytes.concat(
                "Request(ForwardRequest tx,",
                bytes(method),
                " details)ForwardRequest(address from,address to,uint256 nonce,string method)",
                bytes(_methodHash)
            );
        } else {
            _fhash = bytes.concat(
                "Request(",
                bytes(method),
                " details,ForwardRequest tx)",
                bytes(_methodHash),
                "ForwardRequest(address from,address to,uint256 nonce,string method)"
            );
        }

        return keccak256(_fhash);
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @dev Act like an constructor for Initializable contract
     * @param factoryAddress Factory contract address
     */
    function initialize(address factoryAddress) external initializer {
        __EIP712_init("Arcana Forwarder", "0.0.1");
        __Ownable_init();
        __UUPSUpgradeable_init();
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        factory = IFactoryForwarder(factoryAddress);
    }

    // solhint-disable-next-line
    function _authorizeUpgrade(address) internal override onlyOwner {
        emit UpgradeAuth();
    }

    /**
     * @return sender end user who initiated the meta transaction
     */
    function msgSender() internal view virtual returns (address sender) {
        assembly {
            sender := shr(96, calldataload(sub(calldatasize(), 20)))
        }
    }

    /**
     * @dev Fetch nonce fom provided address
     */
    function getNonce(address from) external view returns (uint256) {
        return _nonces[from];
    }

    /**
     * @dev Links newAddress generated by MFA to account
     * @param newAddress new address generated by MFA
     */
    function linkMFAAccount(address newAddress) external {
        require(mfaMapping[msgSender()] != msgSender(), "Already linked");
        mfaMapping[newAddress] = msgSender();
        mfaMapping[msgSender()] = msgSender();
    }

    /**
     * @dev To add/remove a MFA generated address to a particular app
     * @param appAddress Address of the app
     * @param mfaStatus If true uses MFA generated address
     */
    function updateAppLevelMFA(address appAddress, bool mfaStatus) external {
        require(mfaMapping[msgSender()] == msgSender(), "MFA is not enabled");
        mfaEnabledApps[msgSender()][appAddress] = mfaStatus;
    }

    /**
     * @dev verifies meta-transaction on the logic contract
     * @param req ForwardRequest contains data required for meta transaction.
     * `from`- signer, `to`- meta-txn request contract, `nonce`, `data`- encoded function data.
     * @param signature Signature of the meta transaction request.
     */
    function verify(
        ForwardRequest calldata req,
        bytes32 arcanaFunctionData,
        bytes calldata signature
    ) internal view returns (bool) {
        bytes32 fullTypeHash = generateMainTypeHash(req.method);

        bytes memory _fencodeData;

        if (bytes(req.method)[0] > "F") {
            _fencodeData = abi.encode(
                fullTypeHash,
                keccak256(abi.encode(_FORWARDTYPEHASH, req.from, req.to, req.nonce, keccak256(bytes(req.method)))),
                arcanaFunctionData
            );
        } else {
            _fencodeData = abi.encode(
                fullTypeHash,
                arcanaFunctionData,
                keccak256(abi.encode(_FORWARDTYPEHASH, req.from, req.to, req.nonce, keccak256(bytes(req.method))))
            );
        }

        address signer = _hashTypedDataV4(keccak256(_fencodeData)).recover(signature);

        return _nonces[req.from] == req.nonce && signer == req.from;
    }

    /**
     * @dev executes meta-transaction on the logic contract
     * @param req ForwardRequest contains data required for meta transaction.
     * `from`- signer, `to`- meta-txn request contract, `value`, `gas`, `nonce`, `data`- encoded function data.
     * @param signature Signature of the meta transaction request.
     * @param encodedCallData function calldata.
     */
    function execute(
        ForwardRequest calldata req,
        bytes calldata signature,
        bytes calldata encodedCallData
    ) external onlyGatewayNode onlyVallidArcanaContract(req.to) nonReentrant returns (bool, bytes memory) {
        bytes memory arcanaFunctionData = abi.encodePacked(
            keccak256(bytes(methodMappings[req.method])),
            encodedCallData[4:]
        );
        require(verify(req, keccak256(arcanaFunctionData), signature), "invalid_function_signature");
        if (factory.app(req.to) != address(0)) {
            require(IArcanaForwarder(req.to).isActive(), "deleted_app");
        }
        _nonces[req.from] = req.nonce + 1;

        address fromAddress = req.from;
        if (mfaMapping[req.from] != address(0)) {
            address oldAddress = mfaMapping[req.from];
            if (mfaEnabledApps[oldAddress][req.to] == true || req.to == IFactoryForwarder(factory).did()) {
                fromAddress = mfaMapping[req.from];
            }
        }

        // solhint-disable-next-line
        (bool success, bytes memory returndata) = req.to.call{ gas: 1e6, value: 0 }(
            abi.encodePacked(encodedCallData, fromAddress)
        );
        require(success, string(returndata));
        // Validate that the relayer has sent enough gas for the call.
        // See https://ronan.eth.link/blog/ethereum-gas-dangers/
        assert(gasleft() > uint256(1e6) / 63);
        emit ForwardTransaction(req.from, req.to, req.nonce, req.method);
        return (success, returndata);
    }
}
